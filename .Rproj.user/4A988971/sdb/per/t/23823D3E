{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Applied SFC modelling with R\"\nauthor: \"Antoine Godin\"\ndate: \"12 May 2016\"\noutput: slidy_presentation\n---\n\n## Outline\nTODO\n\n## Installing the dependent libraries and the package\nYou need to install all the required libraries This is for traditional libraries\n```{r, eval=F}\ninstall.packages(\"expm\")\ninstall.packages(\"igraph\")\n```\n\nFor non-conventional libraries, such as the one need to visualize DAGs, you need to do the following\n```{r,eval=F}\nsource(\"http://bioconductor.org/biocLite.R\")\nbiocLite(\"Rgraphviz\")\n```\n\nFinally you can then download the PKSFC package from github and install it locally\n```{r, eval=F}\ninstall.packages(\"path/PKSFC_1.3.tar.gz\", repos = NULL, type=\"source\")\n```\n\n\n## Testing\nNow we're ready to load the package:\n```{r}\nlibrary(PKSFC)\n```\n\n1. Load SIM (download SIM.txt from Github)\n```{r}\nsim<-sfc.model(\"SIM.txt\",modelName=\"SIMplest model from chapter 3 of Godley and Lavoie (2007)\")\n```\n2. Simulate the model\n```{r}\ndatasim<-simulate(sim)\n```\n3. replicate figure 3.2 of page 73.\n```{r, width=10}\nplot(sim$time,datasim$baseline[,\"Yd\"],type=\"l\", xlab=\"\", ylab=\"\", lty=2, \n     ylim=range(datasim$baseline[,c(\"Yd\",\"C_s\")],na.rm=T))\nlines(sim$time,datasim$baseline[,\"C_s\"],lty=3)\nlines(sim$time,vector(length=length(sim$time))+datasim$baseline[\"2010\",\"C_s\"])\nlegend(x=1970,y=50,legend=c(\"Disposable Income\",\"Consumption\",\"Steady State\"),lty=c(2,3,1),bty=\"n\")\n``` \n\n## How does it work?\n\n- The package parses a text file containing the equations\n- It generates an internal representation of the model\n- Allows to simulate the model using a linear solver, the Gauss-Seidel Algorithm\n\n## Source code of SIM\n\n```{r, eval=FALSE}\n#1. EQUATIONS\nC_s = C_d\nG_s = G_d\nT_s = T_d\nN_s = N_d\nYd = W*N_s - T_s\nT_d = theta*W*N_s\nC_d = alpha1*Yd + alpha2*H_h(-1)\nH_s = H_s(-1) + G_d - T_d\nH_h = H_h(-1) + Yd - C_d\nY = C_s + G_s\nN_d = Y/W\n#2. PARAMETERS\nalpha1=0.6\nalpha2=0.4\ntheta=0.2\n#EXOGENOUS\nG_d=20\nW=1\n#INITIAL VALUES\nH_s=0\nH_h=0\n#3. Timeline\ntimeline 1945 2010\n```\n\n\n## A few important points regarding the model source code:\n- The file should not contain any empty lines.\n- You should avoid naming your variables with reserved names in R such as 'in' or 'max'.\n- There should be only one equation per line.\n- There should be only one variable on the left hand side of the equation.\n- You can use R functions such as min, max, or logical operators such as > or <=. In the case the logical operatur returns true, the numeric value will be one. Thus `(100>10)` will return `1`.\n- The lag operator is represented by `(-x)` where `x` is the lag.\n- There should not be any empty lines.\n- You can add as many comments, using the `#` character at the begining of the line. Each comment exactly above an equation will be considered as the description of the equation and will be stored in the internal representation of the sfc model object.\n\n## Internal representation\n\n```{r}\nprint(sim)\n```\n\n## The Gauss Seidel Algorithm\n\n- Principle:\nSolving $Ax=b,\\, A\\in\\mathbb{R}^{n\\times n},\\, b\\in \\mathbb{R}^n$ via an iterative algorithm, where each iteration can be represented by $L x^{k+1} = b-Ux^{k},\\, A=L+U$.\n\n- Pseudo-code:\n  1. Select initial values $x^0$\n  2. While $k<maxIter$ \\& $\\delta < tolValue$\n    a. For each $i=1,...,n$: $$x_i^{k+1}=\\frac{1}{a_{ii}}\\left( b_i-\\sum^{i-1}_{j=1}a_{ij} x_j^{k+1}-\\sum_{j=i+1}^n a_{ij}x_j^k\\right)$$\n    b. Compute $\\delta$: $$\\delta = \\frac{x^{k+1}-x^k}{x^k}$$\n\n## Direct Acyclic graphs\n\n```{r}\nsimex<-sfc.model(\"SIMEX.txt\",modelName=\"SIMplest model with expectation\")\nlayout(matrix(c(1,2),1,2))\nplot_graph_hierarchy(graph=generate.DAG.collaspe(adjacency=t(sim$matrix))$orginal_graph,\n                     main=\"SIM\" )\nplot_graph_hierarchy(graph=generate.DAG.collaspe(adjacency=t(simex$matrix))$orginal_graph,\n                     main=\"SIMEX\" )\n```\n\n## Systems of dependent vs independent equations \n\n```{r}\ndatasimex<-simulate(simex)\ninit = datasimex$baseline[66,]\nsimex<-sfc.addScenario(simex,\"G_d\",25,1960,2010,init)\ndatasimex<-simulate(simex)\ndatasim<-simulate(sim)\ninit = datasim$baseline[66,]\nsim<-sfc.addScenario(sim,\"G_d\",25,1960,2010,init)\ndatasim<-simulate(sim)\nplot(sim$time,datasim$scenario_1[,\"H_s\"],type=\"l\",xlab=\"\",ylab=\"\",main=\"SIM\")\nlines(sim$time,datasim$scenario_1[,\"C_d\"],lty=2)\nlines(sim$time,datasim$scenario_1[,\"Yd\"],lty=3)\nlegend(x=1944,y=130,legend=c(\"Wealth\",\"Consumption\",\"Disposable Income\"),\n       lty=c(1,2,3),bty=\"n\")\nplot(simex$time,datasimex$scenario_1[,\"H_s\"],type=\"l\",xlab=\"\",ylab=\"\",main=\"SIMEX\")\nlines(simex$time,datasimex$scenario_1[,\"C_d\"],lty=2)\nlines(simex$time,datasimex$scenario_1[,\"Yd\"],lty=3)\nlines(simex$time,datasimex$scenario_1[,\"Yd_e\"],lty=4)\nlegend(x=1944,y=130,legend=c(\"Wealth\",\"Consumption\",\"Disposable Income\",\n                             \"Expecetd Disposable Income\"),lty=c(1,2,3,4),bty=\"n\")\n```\n\n## Computational implications\n\nLet's see how much time it takes to run sim:\n```{r}\nptm <- proc.time()\ndata1<-simulate(sim)\nprint(paste(\"Elapsed time is \",proc.time()[3]-ptm[3],\"seconds\"))\n```\n\nNow lets play with some of the parameters of the simulate function:\n\n1. tolValue\n```{r}\nptm <- proc.time()\ndata2<-simulate(sim,tolValue = 1e-3)\nprint(paste(\"Elapsed time is \",proc.time()[3]-ptm[3],\"seconds\"))\n```\n2. maxIter\n```{r}\nptm <- proc.time()\ndata3<-simulate(sim, maxIter=10)\nprint(paste(\"Elapsed time is \",proc.time()[3]-ptm[3],\"seconds\"))\n```\n\n## Observing the results of the three simulations\n```{r}\nlibrary(knitr)\nkable(round(t(data1$baseline[c(1,2,20,40,66),c(\"G_d\",\"Y\",\"T_d\",\"Yd\",\"C_d\",\"H_s\",\"H_h\")]),digits=3))\nkable(round(t(data2$baseline[c(1,2,20,40,66),c(\"G_d\",\"Y\",\"T_d\",\"Yd\",\"C_d\",\"H_s\",\"H_h\")]),digits=3))\nkable(round(t(data3$baseline[c(1,2,20,40,66),c(\"G_d\",\"Y\",\"T_d\",\"Yd\",\"C_d\",\"H_s\",\"H_h\")]),digits=3))\n```\n\n## Block Gauss-Seidel\nThe order of equations matters, if first compute variables that do not depend on current period, speeds the process. Define blocks of equation independent from the others.\n```{r}\nprint(simex)\n```\n\n\n## Simulation of SIMEX\n```{r}\nptm <- proc.time()\ndataex<-simulate(simex,tolValue = 1e-10)\nprint(paste(\"Elapsed time is \",proc.time()[3]-ptm[3],\"seconds\"))\n```\n\n\n## Results for SIMEX\n```{r}\nkable(round(t(dataex$baseline[c(1,2,20,40,66),c(\"G_d\",\"Y\",\"T_d\",\"Yd\",\"Yd_e\",\"C_d\",\"H_s\",\"H_h\")]),digits=3))\n```\n\n## Output data structure\n- Output is a list of matrix where each element of the list are a scenario\n  * baseline\n  * scenario_i\n- In the result matrix, there is a column indicating the number of iteration in the Gauss-Seidel algorithm per block of equations per period\n\n```{r}\nkable(dataex$baseline)\n```\n\n## Checking the number of iteractions\n\n- For sim, no simulate parameters:\n```{r}\nkable(round(t(data1$baseline[c(1,2,20,40,66),c(\"iter block 2\")]),digits=3))\n```\n- For sim, tolValue fixed:\n```{r}\nkable(round(t(data2$baseline[c(1,2,20,40,66),c(\"iter block 2\")]),digits=3))\n```\n- For sim, maxIter fixed:\n```{r}\nkable(round(t(data2$baseline[c(1,2,20,40,66),c(\"iter block 2\")]),digits=3))\n```\n- For simex, no simulate parameters\n```{r}\nkable(round(t(dataex$baseline[c(1,2,20,40,66),c(\"iter block 1\",\"iter block 2\",\"iter block 3\",\"iter block 4\",\"iter block 5\",\"iter block 6\")]),digits=3))\n```\n",
    "created" : 1463127228045.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "869706219",
    "id" : "23823D3E",
    "lastKnownWriteTime" : 1463130154,
    "last_content_update" : 1463130155871,
    "path" : "/Volumes/ANTOINE/AppliedSFC_R/Lecture1.Rmd",
    "project_path" : "Lecture1.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}